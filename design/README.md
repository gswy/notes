# 设计模式概述

> 设计模式分为三大类型（创建型模式，结构型模式，行为模式），设计模式准则：对接口编程而不是对实现编程；有限使用对象组合而不是继承。



# 创建型模式

- 抽象工厂（Abstract Factory）：让你能创建一系列相关的对象，而无需指定其具体类。
- 生成器（Builder）：使你能够分步骤创建复杂对象。该模式允许你使用相同的代码生成不通类型和形式的对象。
- 工厂方法（Factory Method）：在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。
- 原型（Prototype）：让你能够复制已有对象，而又无需使代码依赖它们所需的类。
- 单例（Singleton）：让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。



# 结构型模式

- 适配器（Adapter）：让接口不兼容的对象能够相互合作。
- 桥接（Bridge）：可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层级结构，从而能在开发时分别使用。
- 组合（Composite）：你可以使用它将对象组合成树状结构，而且能像使用独立对象一样使用它们。
- 装饰（Decorator）：允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。
- 外观（Facade）：能为程序库、框架或其他复杂类提供一个简单接口。
- 享元（Flyweight）：摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。
- 代理（Proxy）：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。



# 行为模式

- 责任链（Chain of Responsibility）：允许你讲请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。
- 迭代器（Iterator）：让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有元素。
- 备忘录（Memento）：允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。
- 状态（State）：让你能够在一个对象的内部状态变化时改变其行为，使其看上去就想改变了自身所属的类一样。
- 模板方法（Template Method）：在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。
- 命令（Command）：它可以将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不通的请求将方法参数化、延迟请求执行或将其放在队列中，且能实现可撤销操作。
- 中介者（Mediator）：能让你减少对象之间混乱无需的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。
- 观察者（Observe）：允许你定义一种订阅机制，可在对象事件发生时通知多个”观察“对该对象的其他对象。
- 策略（Strategy）：能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法对象能够相互替换。
- 访问者（Visitor）：将算法与其所作用的对象隔离开来。